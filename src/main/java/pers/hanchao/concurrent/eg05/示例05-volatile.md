# 示例05-volatile

volatile 易变类型
轻量级synchronized，编码少，开销小，功能少

volatile 保障可见性，不保障原子性和有序性

使用volatile的前提，不受原子性和有序性影响--》原子性操作、状态独立

使用volatile而非synchronized的主要原因：1.编写简单，2.性能较优，3.非阻塞


https://www.ibm.com/developerworks/cn/java/j-jtp06197.html

双重检查锁失效是因为对象的初始化并非原子操作？
https://www.zhihu.com/question/35268028

作者：知乎用户
链接：https://www.zhihu.com/question/35268028/answer/62016374
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

是因为指令重排造成的。直接原因也就是 初始化一个对象并使一个引用指向他 这个过程不是原子的。
导致了可能会出现引用指向了对象并未初始化好的那块堆内存，使用volatile修饰对象引用，防止重排序即可解决。
推荐使用内部静态类做延时初始化，更合适，更可靠。
这个同步过程由JVM实现了。
================================
拿出来解释一下吧：
help = new Help();
主要原因就是这个操作不是原子性的，从而留给了JVM重排序的机会。
JVM的重排序也是有原则的，在单线程中，不管怎么排，保证最终结果一致。注意是单线程。
多线程的情况下指令重排序就会给程序员带来问题。

help = new Help()这个操作可以拆成：
1、栈内存开辟空间给help引用
2、堆内存开辟空间准备初始化对象
3、初始化对象
4、栈中引用指向这个堆内存空间地址
指令重排之后可能会是1、2、4、3；这样重排之后对单个线程来说效果是一样的，
所以JVM认为是合法的重排序，但是在多线程环境下就会出问题，
这里到4的时候help已经指向了一块堆内存！=null ，
只是这块堆内存还没初始化就直接返回了，使用的时候抛NullPointException。
 
 当然这里的几个步骤并不算真正的指令，指令的粒度只会比这个还小，但是可以说明问题。
  加入volatile之后查看汇编代码可以发现多了一句 lock addl $0x0,(%esp)相当于一个内存屏障。
  volatile的作用：保证内存可见性，防止指令重排序，并不保证操作原子性。
  这里用到的就是防止指令重排序的性质。如何实现这些性质的
  ================
  保证可见性：使用该变量必须重新去主内存读取，修改了该变量必须立刻刷新主内存。
  防止重排序：通过插入内存屏障。不保证操作原子性不保证操作原子性不保证操作原子性
  =========================
  手机纯手打。。。
